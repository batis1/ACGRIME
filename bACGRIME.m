% bACGRIME binary version modified on 2023-12-27.
% 1. Change the function input and output.
% 1.5 Set the initialized population be binary population and set the ub=1
% and lb = 0.
% 2. Change the fitness function and comment the FEs.
% 3. Update decision variables by transferFun every iter there is new
% individual generated (only works when the new individual is generated by
% formulation not assign.
% 4. Comment boundaries control.

%% 1. Change the function input and output.
% function [Best_rime, Convergence_curve] = ACGRIME(N, Max_iter, lb, ub, dim, fobj)
function [Best_rime_rate, Best_rime, Convergence_curve, Time]=bACGRIME_v1(N, MaxFEs, dim, A, trn, vald, TFid, classifierFhd)
%% 1.

    tic
    Best_rime = zeros(1, dim);
    Best_rime_rate = inf; % change this to -inf for maximization problems

%% 1.5 Set the initialized population be binary population and set the ub = 0 and lb = 0.
%     Rimepop = initialization(N, dim, ub, lb);
    lb = 0; 
    ub = 1;
    Rimepop = initialization(N, dim, ub, lb) > 0.5;
%     Lb = lb .* ones(1, dim);
%     Ub = ub .* ones(1, dim);
    Lb = lb .* ones(1, dim);
    Ub = ub .* ones(1, dim);
%% 1.5

    FEs = 1; % Number of function evaluations
    Convergence_curve = [];
    Rime_rates = zeros(1, N);
    newRime_rates = zeros(1, N);
    
%     W = 5; % Soft-rime parameters
    ChaosValue = rand(); % Initial value for Logistic map
    a = 4; % Parameter for Logistic map
 
    for i = 1:N

%% 2. Change the fitness function and comment the FEs.
%         Rime_rates(1, i) = fobj(Rimepop(i, :));
        Rime_rates(1, i) = AccSz2(Rimepop(i, :), A, trn, vald, classifierFhd);
%         FEs = FEs + 1;
%% 2.

        if Rime_rates(1, i) < Best_rime_rate
            Best_rime_rate = Rime_rates(1, i);
            Best_rime = Rimepop(i, :);
        end
    end
 
    while FEs < MaxFEs
        % Apply Logistic map for chaos
        
        ChaosValue = a * ChaosValue * (1 - ChaosValue);
%         RimeFactor = ChaosValue * (rand-0.5)*2*cos((pi*FEs/(MaxFEs/10)))*(1-round(FEs*W/MaxFEs)/W);
        E = sqrt(ChaosValue * FEs/MaxFEs);
        newRimepop = Rimepop;
        normalized_rime_rates = normr(Rime_rates);
        w1 = (1-FEs/MaxFEs)^(1-tan(pi*(ChaosValue * rand-0.5))*FEs/MaxFEs); % Adaptive chaotic weight
 
        for i = 1:N
            for j = 1:dim
                r1 = rand();
                r2 = rand();
%                 c1 = 2*exp(-(4*FEs/MaxFEs)^2);
                c2 = rand();
                c3 = rand();
 
                if r1 < E
                    if c3 < 0.5
                        newRimepop(i, j) = Best_rime(1, j) + w1 *  ((Ub(j) - Lb(j)) * c2 + Lb(j));
                    else
                        newRimepop(i, j) = Best_rime(1, j) - w1 * ((Ub(j) - Lb(j)) * c2 + Lb(j));
                    end

%% 3.  Update decision variables by transferFun every iter there is new individual generated (only works when the new individual is generated by formulation)
                    temp = newRimepop(i, j);
                    newRimepop(i, j) = transferFun(newRimepop(i, j), temp, TFid);
%% 3.                    

                end

 
                if r2 < normalized_rime_rates(i)
                    newRimepop(i, j) = Best_rime(1, j);                  
                end
            end
 
            % Gaussian Mutation
            x = newRimepop(i, :);
            m_gaus = x * (1 + ChaosValue * randn(1));
%% 3.  Update decision variables by transferFun every iter there is new individual generated (only works when the new individual is generated by formulation)
            for i = 1:dim
                temp = m_gaus(1, i);
                m_gaus(1, i) = transferFun(m_gaus(1, i), temp, TFid);
            end
 %% 3.           

%% 4. Comment boundaries control.
%             Flag4ub = m_gaus > ub;
%             Flag4lb = m_gaus < lb;
%             m_gaus = (m_gaus .* (~(Flag4ub + Flag4lb))) + ub .* Flag4ub + lb .* Flag4lb;
%% 4.

%% 2. Change the fitness function and comment the FEs.
%             Moth_fitness_m_gaus = fobj(m_gaus);
            m_gaus_fitness= AccSz2(m_gaus, A, trn, vald, classifierFhd);
%             Moth_fitness_s = fobj(x);
            fitness_s = AccSz2(x, A, trn, vald, classifierFhd);
%% 2.

            m_gaus_fitness_comb = [m_gaus_fitness, fitness_s];
            [~, m] = min(m_gaus_fitness_comb);
            if m == 1
                newRimepop(i, :) = m_gaus;
            end
 
%% 4. Comment boundaries control.
%             Flag4ub = newRimepop(i, :) > ub;
%             Flag4lb = newRimepop(i, :) < lb;
%             newRimepop(i, :) = (newRimepop(i, :) .* (~(Flag4ub + Flag4lb))) + ub .* Flag4ub + lb .* Flag4lb;
%% 4.
        end 
       for i = 1:N
%% 2. Change the fitness function and comment the FEs.
%             newRime_rates(1, i) = fobj(newRimepop(i, :));
            newRime_rates(1, i) = AccSz2(newRimepop(i, :), A, trn, vald, classifierFhd);   
%             FEs = FEs + 1;
%% 2.
%             disp('Size of newRime_rates:');
%             disp(size(newRime_rates));
%             disp('Size of Rime_rates:');
%             disp(size(Rime_rates));


            if newRime_rates(1, i) < Rime_rates(1, i)
                Rime_rates(1, i) = newRime_rates(1, i);
                Rimepop(i, :) = newRimepop(i, :);
 
                if newRime_rates(1, i) < Best_rime_rate
                    Best_rime_rate = Rime_rates(1, i);
                    Best_rime = Rimepop(i, :);
                end
            end
        end
 
        Convergence_curve(FEs) = Best_rime_rate;
        FEs = FEs+1;
    end
    Time = toc;
end

